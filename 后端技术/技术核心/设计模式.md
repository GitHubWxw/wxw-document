### 设计模式



### 常见问题

(1) 策略模式、工厂模式和责任链模式的区别

> 策略模式与工厂模式

- 工厂方法处理问题比较单一，工厂模式在main函数中可以拼装
- 策略模式处理方法比较全面，策略模式在main函数中不可以拼装
- 工厂模式算法都是暴露给程序员的，策略模式比较隐秘

> 责任链模式

- 可扩展性好、增加新的请求处理类很方便。



### 设计原则

#### 1. 单一职责原则

#### 2. 里氏替换原则

#### 3. 依赖倒置原则

#### 4. 接口隔离原则

#### 5. 开闭原则

### 创建型模式

#### 1. 单例模式

#### 2. 工厂模式

### 结构型模式

#### 1. 代理模式

### 行为型模式

#### 1. 责任链模式

##### （1）模式定义

**责任链模式（Chain of Responsibility Pattern）** 使多个对象都有机会处理请求，从而避免了多个请求发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理该请求为止。

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

##### （2）主要解决的问题

> 意图

避免请求发送者与接收者耦合在一起。让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

> 主要解决

职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

> 何时使用

在处理消息的时候以过滤很多道。

> 如何解决

拦截的类都实现统一接口。

##### （3）优缺点

> 优点

1. 降低耦合度。它将请求的发送者和接收者解耦。
2. 简化了对象。使得对象不需要知道链的结构。
3. 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。
4. 增加新的请求处理类很方便。

> 缺点

1. 不能保证请求一定被接收。 
2. 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 
3. 可能不容易观察运行时的特征，有碍于除错。

##### （4）适用场景

1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 
2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
3. 可动态指定一组对象处理请求，或添加新的处理者。

适用于多节点的流程处理，每个节点完成各自负责的部分，节点之间不知道彼此的存在，比如：

1. OA 的审批流
2. Java Web 开发中的 Filter 机制。
3. 击鼓传花游戏

##### （5）实战案例

责任链模式设计两个角色：

1. **抽象处理者角色（Handler）:** 该角色对请求进行抽象，并定义一个方法以设定和返回对下一个处理者的引用。
2. **具体处理者角色（Concrete Handler）** : 该角色接到请求后，可以将请求处理掉，或者将请求传给下一个处理者，由于具体处理者持有对下一个处理者的引用，因此如果需要，具体处理者可以访问下一个处理者。

> 代码示例

源码地址：[快速访问](https://github.com/GitHubWxw/java-general/tree/master/java-designpattern/src/main/java/com/wxw/chain) 

责任链中一个处理者对象，其中只有两个行为，一是处理请求，二是将请求转送给下一个节点，不允许某个处理者对象在处理了请求后又将请求转送给上一个节点的情况。对于一条责任链来说，一个请求最终只有两种情况，一是被某个处理对象所处理，另一个是所有对象均未对其处理，前一种情况称该责任链为纯的责任链，对于后一种情况称为不纯的责任链，实际应用中，多为不纯的责任链。

#### 2. 策略模式

在**策略模式（Strategy Pattern）**中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

- 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
- 主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。
- **何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。
- **如何解决：**将这些算法封装成一个一个的类，任意地替换。
- **关键代码：**实现同一个接口。

##### （1）优缺点

> 优点

1. 算法可以自由切换
2. 避免使用多重条件判断
3. 扩展性良好

> 缺点

1. 策略类会增多
2. 所有策略类都需要对外暴露

##### （2）使用场景

1. 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
2. 一个系统需要动态地在几种算法中选择一种。 
3. 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

> **注意事项：**如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。

##### （3）实现

们将创建一个定义活动的 *Strategy* 接口和实现了 *Strategy* 接口的实体策略类。*Context* 是一个使用了某种策略的类。

*StrategyPatternDemo*，我们的演示类使用 *Context* 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。

![](https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg) 

代码地址：[快速访问](https://github.com/GitHubWxw/java-general/tree/master/java-designpattern/src/main/java/com/wxw/strategy) 



















































