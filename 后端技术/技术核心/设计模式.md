### 设计模式



### 设计原则

#### 1. 单一职责原则

#### 2. 里氏替换原则

#### 3. 依赖倒置原则

#### 4. 接口隔离原则

#### 5. 开闭原则

### 创建型模式

#### 1. 单例模式

### 结构型模式

#### 1. 代理模式

### 行为型模式

#### 1. 责任链模式

##### （1）模式定义

**责任链模式（Chain of Responsibility Pattern）** 使多个对象都有机会处理请求，从而避免了多个请求发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理该请求为止。

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。



##### （2）主要解决的问题

> 意图

避免请求发送者与接收者耦合在一起。让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

> 主要解决

职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

> 何时使用

在处理消息的时候以过滤很多道。

> 如何解决

拦截的类都实现统一接口。

##### （3）优缺点

> 优点

1. 降低耦合度。它将请求的发送者和接收者解耦。
2. 简化了对象。使得对象不需要知道链的结构。
3. 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。
4. 增加新的请求处理类很方便。

> 缺点

1. 不能保证请求一定被接收。 
2. 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 
3. 可能不容易观察运行时的特征，有碍于除错。

##### （4）适用场景

1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 
2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
3. 可动态指定一组对象处理请求，或添加新的处理者。

适用于多节点的流程处理，每个节点完成各自负责的部分，节点之间不知道彼此的存在，比如：

1. OA 的审批流
2. Java Web 开发中的 Filter 机制。
3. 击鼓传花游戏

##### （5）实战案例

责任链模式设计两个角色：

1. **抽象处理者角色（Handler）:** 该角色对请求进行抽象，并定义一个方法以设定和返回对下一个处理者的引用。
2. **具体处理者角色（Concrete Handler）** : 该角色接到请求后，可以将请求处理掉，或者将请求传给下一个处理者，由于具体处理者持有对下一个处理者的引用，因此如果需要，具体处理者可以访问下一个处理者。

> 代码示例

源码地址：[快速访问](https://github.com/GitHubWxw/java-general/tree/master/java-designpattern/src/main/java/com/wxw/chain) 

责任链中一个处理者对象，其中只有两个行为，一是处理请求，二是将请求转送给下一个节点，不允许某个处理者对象在处理了请求后又将请求转送给上一个节点的情况。对于一条责任链来说，一个请求最终只有两种情况，一是被某个处理对象所处理，另一个是所有对象均未对其处理，前一种情况称该责任链为纯的责任链，对于后一种情况称为不纯的责任链，实际应用中，多为不纯的责任链。

























































